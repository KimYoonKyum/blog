---
date: '2023-02-01'
title: '웹브라우저 & HTML 정리'
categories: ['Web', 'HTML', 'Browser']
summary: '웹브라우저와 HTML 공부하면서 정리한 내용들'
thumbnail: './web_browser.png'
---

### 웹 브라우저

- 웹서버와 쌍방향 통신하고 HTML문서나 파일을 출력하는 사용자 인터페이스
- 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시, 자원의 주소는 URI에 의해 정해짐.
- 웹 브라우저는 웹 페이지 가져오기 위해서(또는 정보 송신위해서) HTTP 프로토콜을 사용
  - URI: 인터넷에 있는 자원을 나타내는 유일한 주소(https://test.com/t/1)
  - URL: URI의 서브셋이고, 네트워크 상에 자원이 어디에 위치해있는지 알려주기위한 규약(https://test.com/t)
  - HTTP:HTML과 같은 문서 가져올 수 있는 프로토콜. 서버와 클라이언트 사이에서 메세지 어떤형식으로 주고받을지 규약.80번 포트 사용하고,
  리퀘스트와 리스폰스 구조로 되어있음
  - HTTPS: HTTP 통신을 암호화 하기위해서 SSL/TLS 레이어 얹어서 사용하는 프로토콜

### 웹 브라우저 구조
- 사용자 인터페이스: 주소표시줄, 이전/다음 버튼, 북마크 메뉴 등 웹 페이지창 제외한 모든 부분
- 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작 제어
- 렌더링 엔진: 요청한 콘텐츠를 표시해주는 엔진. HTML,CSS 파싱하여 화면에 표시. 서버에서 받은 데이터를 웹에 뿌려주는데,
  브라우저 마다 렌더링 엔진이 다 다르다. 크롬같은 경우는 웹킷엔진이고 파폭은 게코엔진. 이런 렌더링 엔진 차이 때문에 크로브라우징 이슈가 생김
  서버에서 응답받은 html 문서를 파싱하여 dom 트리만들고, css도 마찬가지로 파싱해서 dom트리와 합쳐 렌더링 트리를 만든다.
  트리가 만들어지면 순차적으로 화면에 배치하고 배치후에 UI백엔드가 트리의 각 노드를 가로지르면서 형상을 그려낸다.
  (만약 html 중간에 script 태그가 있으면 제어 권한을 자바스크립트 해석기에 넘기고 DOM파싱을 중단한다.)
- 통신: HTTP 요청과 같은 네트워크 호출에 사용
- UI백엔드: 콤보박스와 창 같은 기본적인 장치를 그림.

- 자바스크립트 해석기: 자바스크립트 코드 해석/실행
  자바스크립트 엔진: 대표적인 엔진은 구글 V8엔진.

- 자료저장소: 자료 저장 계층. 쿠키/스토리지등 사용자 디스크에 자료 자원 저장
  세션: http는 서버가 클라 요청에 응답하면 연결 끊고 연결끊은 뒤에는 클라이언트 상태 저장안함.
  실제로는 데이터 유지가 필요한 경우들이 있는데 이때 쿠키랑 세션을 사용. 그 중에서 세션은 서버에 방문자의 요청에 따른 정보를 저장하는 것을 말한다.
  쿠키:서버가 사용자의 웹 브라우저에 전송하는 작은 텍스트조각
  로컬스토리지: 브라우저가 닫혀도 정보가 계속 남아있는 저장소
  세션스토리지: 브라우저 창을 닫는 순간까지 정보가 유지되는 저장소
  로컬스토리지와 세션스토리지 둘다 5MB 정도 저장할 수 있고, HTML5 지원하지않는 브라우저 경우 사용못함.

- 웹 브라우저 동작 과정
사용자가 주소창에 url 입력하면 dns 서버로 가서 웹사이트가 있는 서버의 진짜 주소를 찾고
브라우저는 서버에 HTTP 요청 메세지를 보냄. 응답을 받은 브라우저는 html이나 css 파일을 해석해서 화면에 보여줌
DNS: 도메인 네임 시스템. 호스트의 도메인 이름을 IP주소로 바꾸거나 IP주소를 도메인 이름으로 바꾸기 위해 개발된 것

- SOP(Same Origin Poilicy)
다른 출처의 리소스를 사용하는 것을 제한하는 보안 방식

- CORS
크로스 오리진 리소스 쉐어링. 교차출처리소스 공유.
웹 앱이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 웹 브라우저에게 알려주는 체제.
그렇지만 보안상의 이유로 브라우저는 이 교차 출처 http 요청을 막는다. 그래서 다른 출처의 리소스를 불러오려면
출처에서 cors 헤더를 포함한 응답을 반환해야함

- Preflight Request
  option 메소드를 통해서 다른 도메인의 리소스에 요청이 가능한지 확인하는 사전 요청
  이 요청이 가능하다면 실제 요청을 보낸다.
  프리플라이트가 필요한 경우: cors를 모르는 서버를 위해서(cors 관련 아무런 설정이 없는 서버)
  cors에 관한 설정이 없는 서버에 그냥 요청을 하게된다면 서버에서 요청이 처리되었지만
  브라우저에서 cors 에러가 생기기 때문
  또한, 응답을 캐시할 수 있는 시간도 제공한다.

- Simple Request
  preflight 요청 없이 바로 요청하는 것

-Credentialed Request
인증 관련 헤더를 포함할떄 사용하는 요청
좀 더 보안을 강화하기 위해서 사용하는데, credentials 옵션을 설정해준다.
same-origin이나 include로 하면 모든 요청에 인증 정보를 담을 수 있는데
같은 출처라도 서버에서 access-control-allow-credential의 값이 true 여야만 cors 에러에 걸리지 않는다.
access-control-allow-origin의 값이 와일드카드라도 안됨

- CORS 에러가 나는 이유?
리퀘스트 헤더의 origin과 리스폰스의 access-control-allow-origin이 다르기 때문
(프로토콜,호스트,포트까지 같아야함)

- CORS 에러가 나는 세가지 시나리오
1. Preflight Request
2. Simple Request
3. Credentialed Request


- 해결 방법
1. access-control-allow-origin의 값을 알맞게 설정
2. 주로 dev 환경에서 cors 정책위반에 많이 걸렸는데, 프록시 서버를 하나 두고 그거 통해서 요청보내면된다.

- CSRF
사용자의 의지와 무관하게 공격자가 의도한 행동들을 실행시켜 사이트를 위협하는 공격 방법
예를 들어 사용자 모르게 img 태그에 특정 행위를 하는 링크를 걸어두어 클릭했을시에 특정 행위를 실행하도록 하는것.
방어방법은 세션에 토큰을 발급해서, 특정 행위가 일어날 때에 그 토큰이 없으면 행위가 일어나지 않게 하면 된다.
권한을 악용하여 서버를 공격하는 것

- XSS
사용자로 위장한 해커가 사이트에 악의적인 스크립트를 넣는 기법.
예를 들어 게시판에서 게시글을 쓸 때, 스크립트 코드를 넣어서 서버에 업로드 하여
업로드한 게시물이 로드되었을때 사용자 화면에서 악성 스크립트가 실행되게 하는 것.
방어 방법은 스크립트 코드 필터링 하는 것

- HTTP 1.1과 HTTP2의 차이
HTTP1.1의 동작 방식은 하나의 커넥션에서 하나의 요청만을 처리한다. 그래서 동시에 여러 요청을 보내서 동시에 받아올수가 없고
받아올 리소스의 개수가 많아지면 대기시간도 그만큼 길어진다.
또한, HOL Blocking 현상도 발생할수 있는데,
이 현상은 파이프라이닝에서 발생한다. 파이프라이닝은 http 헤더에서 keep-alive 설정을 해줘서
한 커넥션에서 응답을 기다리지 않고 연속적으로 요청을 보내는 기능이다. 여기서 첫번째 요청의 처리가
끝날때까지 뒤에 있는 요청이 대기하는 상황이 나오는데 이것이 Head of Line Blocking 현상이다.

- HTTP1.1의 단점을 극복하기 위해서 여러가지 트릭들이 있는데
  1. 이미지 스프라이팅
     아이콘같은 이미지들을 하나의 이미지 파일로 만들어 좌표값으로 가져오는 기법이다.
  2.도메인샤딩
  3.minify css 파일 적용
  4.이미지를 bas64 인코딩된 데이터로 받아서 클라이언트에서 그려준다.

- 이러한 문제를 보완해서 나온게 HTTP2. HTTP2의 목표는 지연시간 최소화
 1.HTTP 헤더 압축을 하여 용량 대비 효율을 높이는 방법을 사용했다.
 2.한개의 커넥션으로 여러개의 요청을 보낼 수 있다.
 3.응답순서에 상관없이 스트림으로 주고 받는다(1.1 파이프라이닝의 개선 버전).
 여기에 리소스간 상관관계에 따라 우선순위를 부여하여 리소스를 로드한다.


