---
date: '2023-02-19'
title: '리액트 핸드북'
categories: ['React', 'study']
summary: '들고다니면서 볼 리액트 핸드북'
thumbnail: './react_logo.png'
---

### React

# React를 실행하기 위해 필요한 것들
- nodejs
  - 구글의 v8엔진 기반 자바스크립트 런타임 환경(실행 가능하게 해주는 것을 런타임 환경)
  - nodejs를 통해서 패키지를 다운받고 관리할 수 있다
- webpack
  - 자바스크립트 모듈 번들러. 웹앱 개발에 필요한 html,css, js 등 하나 또는 여러개의 파일로 병합 및 압축해주는 역할
- babel
  - es6 이상의 자바스크립트 코드나 jsx, typescript 코드를 브라우저가 읽을 수 있는 자바스크립트 코드로 변환해주는 것 트랜스파일러라고 부른다.
- polyfill
  - 트랜스 파일러로 변환이 불가능한 코드를 직접 구현한 것을 말한다.
- npm vs vs npx vs yarn
  - npm과 yarn의 차이는 패키지 설치 프로세스를 처리하는 방식인데 npm은 패키지를 한번에 하나씩 순차적으로 설치하고 yarn은 여러패키지를 병렬적으로 설치한다 그래서 yarn이 더 속도가 빠르다고한다. 또한 yarn은 lock 파일을 통해 패키지 버전 잠금을 지원해서 어느 환경이던 항상 동일한 패키지를 지원한다.(npm도 package-lock.json이 있긴하다.)npx는 패키지를 실행 시키는 도구
- package.json
  - 패키지 의존성 정보 적어둔 파일
- npm 버전의 의미: {메이저}.{마이너}.{패치}
  - 메이저: api 호환성 깨질 정도 버전
  - 마이너: 하위 버전의 호환성을 지키는 버전
  - 패치: 하위 호환성 유지하면서 버그수정
  - ~ : 현재 지정한 버전 마지막 자리 내에서만 자동 업데이트
  - ^ : 마이너 버전과 패치 버전의 호환성을 지키는 수준내에서의 업데이트

# React
- 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리
- jsx: 자바스크립트를 확장한 문법, html 코드를 작성하듯이 사용가능하다. 바벨을 통해 트랜스파일되서 자바스크립트 코드로 변환된다. 공식적인 자바스크립트 문법은 아니다. xss 공격을 방지
- 엘리먼트
  - 리액트 앱의 가장 작은 단위이고, 일반 객체이다.
  - 리액트 dom 은 리액트 엘리먼트와 일치하도록 dom을 업데이트한다.
  - 엘리먼트는 불변객체이다. 한번 생성한후 변경되지 않고, 업데이트 하려면 렌더를 새로 해야한다.
- 컴포넌트
  - props라는 파라미터를 받고, 화면에 어떻게 표시되는지 나타내는 리액트 엘리먼트 반환
  - 함수형 컴포넌트, 클래스형 컴포넌트가 있다.
  - 리액트 컴포넌트는 자신의 props를 다룰떄 반드시 순수함수 처럼 동작해야한다.(동일한 입력값에는 동일한 결과가 나오게)
- 함수형 컴포넌트 vs 클래스형 컴포넌트
  - 클래스는 Component 객체를 상속받아 구현하고 render 함수를 꼭 오버라이딩 해줘야한다.
  - state를 가질수 있고 라이프 사이클을 각각 구현할 수 있다.
  - 함수형은 state와 render 함수를 구현하지 않아도 되고
  - hook을 사용하여 상태 관리를 할 수 있다.
  - 현재는 리액트 공식문서에서 함수형+훅 사용을 권장하고있다.
- state & props
  - state는 컴포넌트 자기 자신이 가지고 있는 값.
  - props는 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할때 사용. 읽기 전용

- 클래스형 컴포넌트에서는 state를 setState를 통하지 않고 값을 바꾸면 렌더가 안된다.
  - 컴포넌트는 자신의 state를 자식에게 props로 전달 가능하다.
  - 이것을 하향식 또는 단방향식 데이터 흐름이라고 한다.
- 리액트에서는 반드시 preventDefault를 명시적으로 호출해야한다.
- key: 엘리먼트 식별 할 수 있도록 엘리먼트에 고유성을 부여하는 것. 엘리먼트 형제 사이에서만 고유하면된다.
- 제어컴포넌트 vs 비제어 컴포넌트
  - 리액트에 의해 값이  제어되는 입력폼 엘리먼트를 제어 컴포넌트라고 한다
  - 오직 신뢰 가능한 단일 출처 값에 의해서만 입력값을 제어한다.
  - 비제어 컴포넌트는 dom에 접근하여 입력 값을 제어하는 것
- Context API
  - props drilling을 하지않고 컴포넌트 트리 전체에 데이터를 제공할 수 있게해주는 것
  - createContext 만들어진 객체는 Provider와 Consumer 컴포넌트를 가진다.
  - Provider는 value를 받아 하위 컴포넌트에 전달하는 역할이고
  - Consumer는 그 value들을 구독하는 컴포넌트이다.
- 자바스크립트의 클래스 메소드는 기본적으로 바인딩 되어 있지 않아서 onclick 같은 인자에 바인딩 하지 않고 넘기면 undefined가 나온다
  - 이벤트핸들러에 함수를 전달할때 화살표함수를 쓰면 매번 새로운 콜백이 형성되기 때문에
  - 왠만하면 클래스로 작성해서 명시적으로 바인딩해준 함수를 넘겨주는것이 좋다
- 리액트에서는 상속대신 합성을 통해서 컴포넌트를 재사용하는 것을 권장한다.
  - 아직 상속으로 작성하는 권장할만한 사례가 없다고한다.
- lazy 컴포넌트는 동적으로 import하는 함수를 인자로 가지고 suspense와 함께 쓰인다.
  - import 해서컴포넌트를 가져올떄까지 suspense의 fallback으로 예비컨텐츠 보여준다.
- HOC 고차컴포넌트
  - 컴포넌트를 가져와서 새로운 컴포넌트로 반환하는 함수
  - 저는 고차컴포넌트 사용했던 경우는 특정 컴포넌트에서 mobx store 코드 사용못하도록 강제 예외처리 해주기 위해서 사용했습니다.
- 성능최적화
  - 리액트에는 유용한 경고들이 많은데 개발환경에서는 이 경고들을 사용해서 유용하다.
  - 그렇지만 그만큼 앱을 느리게 만들기 떄문에 프로덕션 버젼 빌드해서 배포
  - 긴 목록같은 경우에는 react-window 같은 라이브러리 사용(주어진 시간에 현재 목록만 렌더링하여 dom 개수 많이 줄여줌)
- 리액트 쓰면서 드는 생각
  - 가상 dom과 실제 dom 비교할때 diffing 알고리즘인 휴리스틱 알고리즘을 어떻게 o(n)복잡도로 만들었는지 신기하다
  - 휴리스틱 알고리즘중에 가정 첫번째인 두 개의 엘리먼트는 서로다른 두개의 트리를 만들어 낸다. 그래서 엘리먼트 하나가 바뀌면그 아래 엘리먼트도 싹 바뀐다.
- ref
  - 생성된 엘리먼트나 dom에 접근하는 방법

- 리액트 생명주기
  - 마운트시
    - constructor -> getderivedStateProps -> render -> componentDidMount
  - 업데이트시
    - getDerivedStateFromPros -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate ->componentDidUpdate
  - 언마운트시
    - componentWillUnmount
  - pure component 
    - 상태값 변경을 체크해서 렌더링 할떄 깊은 비교가 아닌 얕은 비교를하는 컴포넌트

  - 리액트 hook
    - 함수형 컴포넌트에서 상태와 컴포넌트 생명주기를 관리할수 있는 함수
      - useState: 상태 선언하고 변경할 수 있는 함수를 반환하는 함수
      - useEffect: 컴포넌트의 상태가 변경되었을때 사이드이펙트로 콜백함수를 실행하는 함수
      - 의존성 배열을 통해 특정상태가 변할때만 수행 가능하게도 할수 있다
      - useContext: 가장 가까운 context를 반환하는 함수
      - 메모이제이션? 연산된 결과값을 저장해두고 동일한 입력값에 대해 결과값을 연산하지 않고 재사용할 수 있게하는 개념
      - useCallback: 메모이제이션된 콜백 함수를 반환. 메모이제이션된 값이 변경될떄 까지 값을 저장해놓고 재사용 가능하게 할수 있다.
      - useMemo: 메모이제이션된 값을 반환
      - useLayoutEffect: 동기적으로 사이드이펙트를 실행할때 사용하는 함수
      - 리액트에서는 권장하지 않고 useEffect를 사용해보고 이상이 있을때 이것을 사용하라함

- react18버전
  - 서버사이드렌더링 지원하고
  - 자동으로 배치해주는 기능 추가.
    - 여러 상태가 업데이트 될때, 업데이트 될떄마다 렌더 하는게 아니라 묶어서 렌더링


### 참고 문서

- [<https://ko.reactjs.org/>](<https://ko.reactjs.org/>)